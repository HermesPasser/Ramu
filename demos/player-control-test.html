<canvas id="canvas" width="512" height="480" style="border:1px solid #000000;"></canvas>
<script type="text/javascript" src="../Ramu.js"></script>

<script>
// Player Control & Animation Test by Hermes Passer in 09-19-17 using Ramu 0.4


/*
	code of http://nokarma.org/2011/02/27/javascript-game-development-keyboard-input/index.html
	
	var Key = {
	  _pressed: {},

	  LEFT: 37,
	  UP: 38,
	  RIGHT: 39,
	  DOWN: 40,
	  
	  isDown: function(keyCode) {
		return this._pressed[keyCode];
	  },
	  
	  onKeydown: function(event) {
		this._pressed[event.keyCode] = true;
	  },
	  
	  onKeyup: function(event) {
		delete this._pressed[event.keyCode];
	  }
	};
	window.addEventListener('keyup', function(event) { Key.onKeyup(event); }, false);
	window.addEventListener('keydown', function(event) { Key.onKeydown(event); }, false);
*/

class Player extends GameObj{
	constructor(x, y, width, height){
		super(x,y, width, height);
		
		// Create because GameObj doesn't contains width and height
		this.width  = width;
		this.height = height;
		
		// Colliders to detect collision
		this.mainCol   = new SimpleRectCollisor(x, y, width, height);
		
		this.anim = {};
		this.inGround = false;
	}
	
	addAnimation(nameID, animation){
		animation.x = this.x;
		animation.y = this.y;
		animation.canDraw = false;
		this.anim[nameID] = animation;
	}
	
	setCurrentAnimation(nameID){
		for (var key in this.anim)
			this.anim[key].canDraw = false;
		
		if (this.anim[key] != null)
			this.anim[nameID].canDraw = true;
	}
	
	setFlipHorizontally(bool){
		for (var key in this.anim)
			this.anim[key].flipHorizontally = bool;
	}
	
	setFlipVertically(bool){
		for (var key in this.anim)
			this.anim[key].flipVertically = bool;
	}
	
	setX(x){
		for (var key in this.anim)
			this.anim[key].x = x;
		this.mainCol.x 	= x;
		this.x = x;
	}
	
	setY(y){
		for (var key in this.anim)
			this.anim[key].y = y;
		this.mainCol.y  = y;
		this.y = y;
	}	
	
	addX(x){
		for (var key in this.anim)
			this.anim[key].x += x;
		this.mainCol.x  += x;
		this.x += x;
	}
	
	addY(y){
		for (var key in this.anim)
			this.anim[key].y += y;
		this.mainCol.y  += y;
		this.y += y;
	}
	
	update(){
		if (this.x > canvas.width)
			this.setX(-this.width - 1);
		else if (this.x < -this.width)
			this.setX(canvas.width);
	}
}


var state = { idle: 0, run: 1, jump: 2, rouch: 3, climb_idle: 4, climb: 4 }
var current = state.idle;
var vel = 50;
	var  x = 200;
	var  y = 300;
class MyGame extends Drawable{
	start(){
		Ramu.debugMode = true;
		
		// Animation
		
		var lum_idle = new SpritesheetAnimation("lum-rip-by-rojimenez.png", 40, 40, 25, 50);
		lum_idle.addFrame(new Rect(0,0,25,50));
		
		var lum_run = new SpritesheetAnimation("lum-rip-by-rojimenez.png", 80, 40, 25, 50);
		lum_run.addFrame(new Rect(0,0,25,50));
		lum_run.addFrame(new Rect(25,0,25,50));
		lum_run.addFrame(new Rect(50,0,25,50));
		lum_run.animationTime = 0.2;
		
		
		var lum_jump = new SpritesheetAnimation("lum-rip-by-rojimenez.png", 140, 40, 25, 50);
		lum_jump.addFrame(new Rect(75,0,25,50));
		lum_jump.addFrame(new Rect(101,0,25,50));
		lum_jump.animationTime = 0.2;
		
		var lum_climb_idle = new SpritesheetAnimation("lum-rip-by-rojimenez.png", 180, 40, 25, 50);
		lum_climb_idle.addFrame(new Rect(125,0,25,50));
		
		var lum_climb = new SpritesheetAnimation("lum-rip-by-rojimenez.png", 180, 40, 25, 50);
		lum_climb.addFrame(new Rect(125,0,25,50));
		lum_climb.addFrame(new Rect(151,0,25,50));
		lum_climb.animationTime = 0.2;
		
		var lum_crouch = new SpritesheetAnimation("lum-rip-by-rojimenez.png", 200, 40, 25, 50);
		lum_crouch.addFrame(new Rect(175,0,25,50));
		
		
		// Player
		
		this.lum = new Player(300,300,25,50);
		this.lum.addAnimation("idle", lum_idle);
		this.lum.addAnimation("run", lum_run);
		this.lum.addAnimation("jump", lum_jump);
		this.lum.addAnimation("climb_idle", lum_climb_idle);
		this.lum.addAnimation("climb", lum_climb);
		this.lum.addAnimation("rouch", lum_crouch);
		this.lum.setCurrentAnimation("idle");
	}
	
	update(){
		// if (Key.isDown(keyCode.space)) alert("up");
		// if (Key.onKeydown(keyCode.space)) alert("up");
		
		// Preciso de controle de inputs que me deixem saber quando press down, up e se nÃ£o esta
		// Protip: Don't store "true", store the epoch time the event occurred. 
		// Now you have TWO pieces of useful information about the press, and 
		// can do smarter event handling because you know when it was pressed, 
		// so you can increase or decrease an effect, or just turn it off after 
		// a max time.

		// ref: http://nokarma.org/2011/02/27/javascript-game-development-keyboard-input/index.html
		
		ctx.save()
		ctx.scale(-1, 1)
		ctx.restore()
		
		switch(current){
			case state.idle:
				this.lum.setCurrentAnimation("idle");
				break;
			case state.run:
				this.lum.setCurrentAnimation("run");
				break;
			case state.jump:
				this.lum.setCurrentAnimation("jump");
				break;
			case state.rouch:
				this.lum.setCurrentAnimation("rouch");
				break;
			case state.climb_idle:
				this.lum.setCurrentAnimation("climb_idle");	
				break;
		}
	
		// Climb idle
		if (keyCode.w in Ramu.pressedKeys){
			current = state.climb_idle;
			
			// Climb
			if (keyCode.a in Ramu.pressedKeys){
				current = state.climb;
				this.lum.setCurrentAnimation("climb");	
				this.lum.addX(-(vel * Ramu.time.delta));
				this.lum.setFlipHorizontally(false);
			} else if (keyCode.d in Ramu.pressedKeys){
				current = state.run;
				this.lum.setCurrentAnimation("climb");
				this.lum.addX(vel * Ramu.time.delta);
				this.lum.setFlipHorizontally(true);
			}
		}
		
		// Run
		else if (keyCode.a in Ramu.pressedKeys){
			current = state.run;
			this.lum.addX(-(vel * Ramu.time.delta));
			this.lum.setFlipHorizontally(false);
		}
			
		else if (keyCode.d in Ramu.pressedKeys){
			current = state.run;
			this.lum.addX(vel * Ramu.time.delta);
			this.lum.setFlipHorizontally(true);
		}
		
	
		// Rouch
		else if (keyCode.s in Ramu.pressedKeys){
			current = state.rouch;
		}
		
		// Jump
		else if (keyCode.space in Ramu.pressedKeys){
			current = state.jump;
		} else current = state.idle;
		
		
	}
	

	draw(){
		ctx.save();

		//The scale will flip the whole canvas, and will move the image 
		//to the left (by the image width size)

		
		var img = new Image()
		img.src = "img/flying_ground.png"
		
		// ctx.drawImage(img,200,300);
		// ctx.strokeRect(x,y, img.width, img.height);
		// ctx.drawImage(img,x,y)


	}
}


new MyGame(0,0,0,0);

Ramu.init(); 

</script>